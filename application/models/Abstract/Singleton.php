<?php/*A universalised singleton template which is free from any business logicand so we're free to use it for any our future singleton.Particularly in this demo project Config class extends it*/abstract class Abstract_Singleton {  // the one and only instance  private static $__instance = null;  // as the construction is protected, no accidental "new" outside is possible  protected function __construct() {  }    public static function singleton() {    if (!isset(self::$__instance)) {       // since this is an abstract class, we will never be creating its instance, i.e. calling new __CLASS__      // so we need to know called class (our descendent) name      // luckily, in PHP 5.3+ it is possible, but in earlier versions that was impossible without hacking the      // debug stack      $className = get_called_class();      if ($className !== false) {        self::$__instance = new $className;      }    }        return self::$__instance;  }  // override magic methods not applicable to singletons    public function __clone() {      trigger_error('Cloning singleton is not allowed.', E_USER_ERROR);  }  public function __wakeup() {      trigger_error('Unserializing singleton is not allowed.', E_USER_ERROR);  }}?>